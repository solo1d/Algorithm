- **要学习它的`“来历”`, `“自身的特点”` ,`“适合解决的问题”` 以及 `“实际的应用场景”`**
- **必须熟练掌握的10种数据结构和10中算法**
    - **10个数据结构:数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树;**
    - **10 个算法:递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算 法、动态规划、字符串匹配算法**
- 



## 目录

- [时间空间复杂度分析](#时间空间复杂度分析)
- [数组查找](#数组查找)
- [链表](#链表)
    - [链表边界检查](#链表边界检查)
- [队列](#队列)
- [递归](#递归)
- [排序](#排序)
    - [归并排序](#归并排序)
    - [快速排序](#快速排序)
    - [线性排序](#线性排序)
      - 



## 时间空间复杂度分析

>  **unit_time**  单位时间

- **所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比**
- **大O表示法, 表示的是代码执行时间随数据规模增长的变化趋势`(asymptotic time complexity)`**
- 公式: `T(n) = O( f(n) )`
    - **`T(n)` 代码执行的时间**
        - `n`  表示数据规模的大小
    - **`f(n)` 表示每行代码执行的次数总和**
    - **公式中的 O，表示代码的执行时间 `T(n)` 与 `f(n)` 表达式成正比**
        - `T(2n+n^2) = O(n^2)`
    - **公式中的低阶、常量、系数三部分并 不左右增长趋势，所以都可以忽略。只需要记录一个最大量级就可以了**
- ==**在分析一个算 法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了**==

```c++
/* 下面代码是  T(2n +2 )= O(n) 代码执行时间 */
int cal(int n) {
	int sum = 0;       // 1个 unit_time 单位时间 
	int i = 1;         // 1个 unit_time 单位时间
	for (; i <= n; ++i) {    // n个 unit_time 单位时间
		sum = sum + i;       // n个 unit_time 单位时间
    }
	 return sum;  // 不计算
}
```

> - **复杂度量级可分为两类`(按数量级递增, 从小到大)`**
>     - **多项式量级**
>         - 常量阶 O(1)
>             - **只要算法中不存在循环语句、递归语句，即使有成千 上万行的代码，其时间复杂度也是Ο(1)**
>         - 对数阶 O(logn)
>             - log一直都是以2为底进行计算
>         - 线性阶 O(n)
>         - 线性对数阶 O(n * longn)
>         - 平方阶  O(n^2), 立方阶 O(n^3)  ,K次方阶 O(n^k)
>     - **非多项式量级**
>         - 指数阶 O(2^n)
>         - 阶乘阶 O( n! )



- 空间复杂度全称就是**渐进空间复杂度**(asymptotic space complexity)，**表示算法的存储空间与数据规模之间的增长关系**。



1. **最好情况时间复杂度**(best case time complexity)
2. **最坏情况时间复杂度**(worst case time complexity)
3. **平均情况时间复 杂度**(average case time complexity)
4. **均摊时间复杂度**(amortized time complexity)











## 数组查找

```c++
// 在数组 a 中，查找 key，返回 key 所在的位置
// 其中，n 表示数组 a 的长度
// 我举 2 个例子，你可以拿例子走一下代码
// a = {4, 2, 3, 5, 9, 6}  n=6 key = 7
// a = {4, 2, 3, 5, 9, 6}  n=6 key = 6
int find(char* a, int n, char key) {
  if(a == null || n <= 0) {
    return -1;
  }
  
  // 这里因为要将 a[n-1] 的值替换成 key，所以要特殊处理这个值
  if (a[n-1] == key) {
    return n-1;
  }
  
  // 把 a[n-1] 的值临时保存在变量 tmp 中，以便之后恢复。tmp=6。
  // 之所以这样做的目的是：希望 find() 代码不要改变 a 数组中的内容
  char tmp = a[n-1];
  // 把 key 的值放到 a[n-1] 中，此时 a = {4, 2, 3, 5, 9, 7}
  a[n-1] = key;
  
  int i = 0;
  // while 循环比起代码一，少了 i<n 这个比较操作
  while (a[i] != key) {
    ++i;
  }
  
  // 恢复 a[n-1] 原来的值, 此时 a= {4, 2, 3, 5, 9, 6}
  a[n-1] = tmp;
  
  if (i == n-1) {
    // 如果 i == n-1 说明，在 0...n-2 之间都没有 key，所以返回 -1
    return -1;
  } else {
    // 否则，返回 i，就是等于 key 值的元素的下标
    return i;
  }
}
```











## 链表

- **利用哨兵简化实现难度**
- **重点留意边界条件处理**



- **链表操作. 写熟练即可**
    - 单链表反转
    - 链表中环的检测
    - 两个有序的链表合并
    - 删除链表倒数第 n 个结点
        - `将下个节点的数据拷贝到指定的n节点, 然后删除后面的那个节点即可, 迭代器就是这么工作的`
    - 求链表的中间结点



### 链表边界检查

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？









## 队列

循环队列是重点, 保留一个空位置, 节省判断操作和一个长度计数变量空间和多次操作.

阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。









## 递归

**1. 一个问题的解可以分解为几个子问题的解**

**2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样**

**3. 存在递归终止条件**

> **编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤**。
>
> **不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码**





## 排序

> **排序算法，就是特指空间复杂度是 O(1) 的排序算法**
>
> n个数的组合方式有 n! 种



- **分析一个排序算法的入手点:**
    - **算法的执行效率:**
        - **最好情况、最坏情况、平均情况时间复杂度**
        - **时间复杂度的系数、常数 、低阶**
            - 小规模数据排序时, 要将 系数、常数、低阶也考虑进来.
        -  **比较次数和交换（或移动）次数**
            - 在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去
    - **排序算法的内存消耗**
    - **排序算法的稳定性**
        - 这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变



### 归并排序

- **归并排序,  分而治之, 将一个数组连续平均拆分, 然后排序, 将结果放入临时变量然后再写回到原数组**
    - 不是原地排序算法
    - 是 稳定排序算法
- **归并排序时间复杂度是 `O(n * log2n)`**
    - **空间复杂度是 `O(n)`**
        - 在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小



### 快速排序

- **快排是一种原地、不稳定的排序算法**
- **将数组先进行排序, 然后拆开, 再排序,一次递归**
- **快排时间复杂度是 `O(n * log2n)`**
  - **空间复杂度是 O(1)**



## 线性排序

> 三种时间复杂度是 O(n) 的排序算法：桶排序、计数排序、基数排序。因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作**线性排序**（Linear sort）。**之所以能做到线性的时间复杂度，主要原因是，这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。**



### 桶排序

- **桶排序比较适合用在外部排序中**
  - 所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中
- **适合每次排序少量数据, 过多或出现问题**











