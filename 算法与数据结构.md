- **要学习它的`“来历”`, `“自身的特点”` ,`“适合解决的问题”` 以及 `“实际的应用场景”`**
- **必须熟练掌握的10种数据结构和10中算法**
    - **10个数据结构:数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树;**
    - **10 个算法:递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算 法、动态规划、字符串匹配算法**
- 



## 目录

- [时间空间复杂度分析](#时间空间复杂度分析)
- [数组查找](#数组查找)
- [链表](#链表)
    - [链表边界检查](#链表边界检查)
    - 



## 时间空间复杂度分析

>  **unit_time**  单位时间

- **所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比**
- **大O表示法, 表示的是代码执行时间随数据规模增长的变化趋势`(asymptotic time complexity)`**
- 公式: `T(n) = O( f(n) )`
    - **`T(n)` 代码执行的时间**
        - `n`  表示数据规模的大小
    - **`f(n)` 表示每行代码执行的次数总和**
    - **公式中的 O，表示代码的执行时间 `T(n)` 与 `f(n)` 表达式成正比**
        - `T(2n+n^2) = O(n^2)`
    - **公式中的低阶、常量、系数三部分并 不左右增长趋势，所以都可以忽略。只需要记录一个最大量级就可以了**
- ==**在分析一个算 法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了**==

```c++
/* 下面代码是  T(2n +2 )= O(n) 代码执行时间 */
int cal(int n) {
	int sum = 0;       // 1个 unit_time 单位时间 
	int i = 1;         // 1个 unit_time 单位时间
	for (; i <= n; ++i) {    // n个 unit_time 单位时间
		sum = sum + i;       // n个 unit_time 单位时间
    }
	 return sum;  // 不计算
}
```

> - **复杂度量级可分为两类`(按数量级递增, 从小到大)`**
>     - **多项式量级**
>         - 常量阶 O(1)
>             - **只要算法中不存在循环语句、递归语句，即使有成千 上万行的代码，其时间复杂度也是Ο(1)**
>         - 对数阶 O(logn)
>             - log一直都是以2为底进行计算
>         - 线性阶 O(n)
>         - 线性对数阶 O(n * longn)
>         - 平方阶  O(n^2), 立方阶 O(n^3)  ,K次方阶 O(n^k)
>     - **非多项式量级**
>         - 指数阶 O(2^n)
>         - 阶乘阶 O( n! )



- 空间复杂度全称就是**渐进空间复杂度**(asymptotic space complexity)，**表示算法的存储空间与数据规模之间的增长关系**。



1. **最好情况时间复杂度**(best case time complexity)
2. **最坏情况时间复杂度**(worst case time complexity)
3. **平均情况时间复 杂度**(average case time complexity)
4. **均摊时间复杂度**(amortized time complexity)











## 数组查找

```c++
// 在数组 a 中，查找 key，返回 key 所在的位置
// 其中，n 表示数组 a 的长度
// 我举 2 个例子，你可以拿例子走一下代码
// a = {4, 2, 3, 5, 9, 6}  n=6 key = 7
// a = {4, 2, 3, 5, 9, 6}  n=6 key = 6
int find(char* a, int n, char key) {
  if(a == null || n <= 0) {
    return -1;
  }
  
  // 这里因为要将 a[n-1] 的值替换成 key，所以要特殊处理这个值
  if (a[n-1] == key) {
    return n-1;
  }
  
  // 把 a[n-1] 的值临时保存在变量 tmp 中，以便之后恢复。tmp=6。
  // 之所以这样做的目的是：希望 find() 代码不要改变 a 数组中的内容
  char tmp = a[n-1];
  // 把 key 的值放到 a[n-1] 中，此时 a = {4, 2, 3, 5, 9, 7}
  a[n-1] = key;
  
  int i = 0;
  // while 循环比起代码一，少了 i<n 这个比较操作
  while (a[i] != key) {
    ++i;
  }
  
  // 恢复 a[n-1] 原来的值, 此时 a= {4, 2, 3, 5, 9, 6}
  a[n-1] = tmp;
  
  if (i == n-1) {
    // 如果 i == n-1 说明，在 0...n-2 之间都没有 key，所以返回 -1
    return -1;
  } else {
    // 否则，返回 i，就是等于 key 值的元素的下标
    return i;
  }
}
```











## 链表

- **利用哨兵简化实现难度**
- **重点留意边界条件处理**



- **链表操作. 写熟练即可**
    - 单链表反转
    - 链表中环的检测
    - 两个有序的链表合并
    - 删除链表倒数第 n 个结点
        - `将下个节点的数据拷贝到指定的n节点, 然后删除后面的那个节点即可, 迭代器就是这么工作的`
    - 求链表的中间结点



### 链表边界检查

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？







